<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Partículas Animadas - S Y R A</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
<script>
  // === Setup básico ===
  const scene    = new THREE.Scene();
  const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);
  camera.position.z = 4;
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));

  // === Partículas iniciais ===
  const particleCount = 2000;
  const geometry  = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const material = new THREE.PointsMaterial({
    size: 0.02, color: 0x00ffff,
    blending: THREE.AdditiveBlending, depthTest: false, transparent: true
  });
  const particles = new THREE.Points(geometry, material);
  scene.add(particles);

  // === Amostragem uniforme por área + ordenação angular ===
  function samplePointsInMesh(geo, count) {
    // prepara triângulos
    const pos   = geo.attributes.position.array;
    const idx   = geo.index ? geo.index.array : null;
    const tris  = [];
    if (idx) {
      for (let i = 0; i < idx.length; i += 3)
        tris.push([ idx[i], idx[i+1], idx[i+2] ]);
    } else {
      for (let i = 0; i < pos.length/3; i += 3)
        tris.push([ i, i+1, i+2 ]);
    }
    // calcula áreas cumulativas
    const areas = tris.map(t => {
      const [a,b,c] = t;
      const ax=pos[3*a], ay=pos[3*a+1];
      const bx=pos[3*b], by=pos[3*b+1];
      const cx=pos[3*c], cy=pos[3*c+1];
      const abx=bx-ax, aby=by-ay, acx=cx-ax, acy=cy-ay;
      return Math.abs(abx*acy - aby*acx) / 2;
    });
    const cum = [], soma = areas.reduce((s,v,i)=>(cum[i]=s+v,s+v),0);

    // amostra pontos
    const pts = [];
    for (let i = 0; i < count; i++) {
      const r = Math.random() * soma;
      let ti = cum.findIndex(c=>c>=r);
      ti = ti < 0 ? areas.length-1 : ti;
      const [a,b,c] = tris[ti];
      const ax=pos[3*a], ay=pos[3*a+1], az=pos[3*a+2];
      const bx=pos[3*b], by=pos[3*b+1], bz=pos[3*b+2];
      const cx=pos[3*c], cy=pos[3*c+1], cz=pos[3*c+2];
      let u=Math.random(), v=Math.random();
      if (u+v > 1) { u = 1-u; v = 1-v; }
      const w = 1 - u - v;
      const x = u*ax + v*bx + w*cx;
      const y = u*ay + v*by + w*cy;
      const z = u*az + v*bz + w*cz;
      pts.push([x,y,z]);
    }

    // centraliza e ordena por ângulo
    const cx = pts.reduce((s,p)=>(s+p[0]),0)/count;
    const cy = pts.reduce((s,p)=>(s+p[1]),0)/count;
    pts.sort((p1,p2)=>{
      return Math.atan2(p1[1]-cy,p1[0]-cx) - Math.atan2(p2[1]-cy,p2[0]-cx);
    });

    // flatten
    const out = new Float32Array(count*3);
    pts.forEach((p,i)=>{ out[3*i]=p[0]; out[3*i+1]=p[1]; out[3*i+2]=p[2]; });
    return out;
  }

  // === Gera um anel “mesh” via ShapeGeometry de um círculo preenchido ===
  function makeRingMesh(segments=64) {
    const shape = new THREE.Shape();
    shape.absarc(0,0,1.2,0,Math.PI*2);
    return new THREE.ShapeGeometry(shape, segments);
  }

  // === Carrega fonte e gera vetores preenchidos de S, Y, R, A ===
  new THREE.FontLoader().load(
    'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
    font => {
      // cria mesh de cada letra, centraliza e amostra
      const letters = ['S','Y','R','A'].map(ch => {
        const geo = new THREE.ShapeGeometry(font.generateShapes(ch, 1.5));
        geo.computeBoundingBox();
        const bb = geo.boundingBox;
        const xMid = -0.5*(bb.max.x+bb.min.x);
        const yMid = -0.5*(bb.max.y+bb.min.y);
        geo.translate(xMid,yMid,0);
        return samplePointsInMesh(geo, particleCount);
      });

      // prepara arrays completos
      const shapes = [
        samplePointsInMesh(makeRingMesh(), particleCount),
        letters[0],
        letters[1],
        letters[2],
        letters[3]
      ];

      // === Animação interpolada ===
      let curr = 0, next = 1;
      let start = performance.now();
      const duration = 2000;

      function easeInOutCubic(t) {
        return t<0.5
          ? 4*t*t*t
          : 1 - Math.pow(-2*t+2,3)/2;
      }

      (function animate(time){
        requestAnimationFrame(animate);
        const tRaw = (time - start) / duration;
        const t = Math.min(tRaw,1);
        const e = easeInOutCubic(t);
        const from = shapes[curr], to = shapes[next];

        for (let i = 0; i < particleCount; i++) {
          const i3 = 3*i;
          positions[i3]     = from[i3]     + (to[i3]     - from[i3])     * e;
          positions[i3 + 1] = from[i3 + 1] + (to[i3 + 1] - from[i3 + 1]) * e;
          positions[i3 + 2] = from[i3 + 2] + (to[i3 + 2] - from[i3 + 2]) * e;
        }
        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);

        if (t === 1) {
          // avança shape quando completa transição
          curr = next;
          next = (next + 1) % shapes.length;
          start = time;
        }
      })(performance.now());
    }
  );

  // === Responsividade ===
  window.addEventListener('resize', () => {
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
