<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vox - SyraDevOps</title>
    <link rel="stylesheet" href="../style.css">
    <style>
        body {
            background-color: #e8f9f0;
            display: block;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .wave-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
            overflow: hidden;
        }

        .sine-wave {
            position: absolute;
            bottom: 20%;
            left: 0;
            width: 100%;
            height: 200px;
            opacity: 0.6;
        }

        .sine-wave svg {
            width: 100%;
            height: 100%;
        }

        .sine-wave path {
            stroke: #90EE90;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 10px rgba(144, 238, 144, 0.3));
            animation: waveFlow 3s linear infinite;
        }

        @keyframes waveFlow {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-100px);
            }
        }

        .vox-container {
            position: relative;
            z-index: 2;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .mic-button {
            background: linear-gradient(135deg, #90EE90, #32CD32);
            border: none;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(144, 238, 144, 0.3);
            position: relative;
            overflow: hidden;
            margin-bottom: 2rem;
        }

        .mic-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(144, 238, 144, 0.4);
        }

        .mic-button:active {
            transform: scale(0.95);
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #FF6B6B, #FF4757);
            animation: pulse 1.5s infinite;
        }

        .mic-icon {
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
        }

        .mic-button:hover .mic-icon {
            transform: scale(1.1);
        }

        .transcription-display {
            position: fixed;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            max-width: 90%;
            text-align: center;
        }

        .transcription-lines {
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px 25px;
            border-radius: 15px;
            font-size: 1rem;
            font-weight: 400;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 15px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            max-height: 200px;
            overflow-y: auto;
            min-width: 300px;
        }

        .transcription-lines.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .transcription-line {
            margin-bottom: 8px;
            padding: 8px 12px;
            background-color: rgba(248, 248, 248, 0.7);
            border-radius: 10px;
            border-left: 3px solid #90EE90;
            animation: slideInLeft 0.5s ease-out;
            line-height: 1.4;
        }

        .transcription-line:last-child {
            margin-bottom: 0;
        }

        .transcription-line.interim {
            opacity: 0.7;
            font-style: italic;
            background-color: rgba(144, 238, 144, 0.1);
            border-left-color: #66BB6A;
        }

        .empty-state {
            color: #888;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .save-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .save-button,
        .clear-button {
            background: linear-gradient(135deg, #90EE90, #32CD32);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(144, 238, 144, 0.3);
        }

        .clear-button {
            background: linear-gradient(135deg, #ff6b6b, #ff5252);
            box-shadow: 0 3px 12px rgba(255, 107, 107, 0.3);
        }

        .save-button:hover,
        .clear-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 16px rgba(144, 238, 144, 0.4);
        }

        .clear-button:hover {
            box-shadow: 0 5px 16px rgba(255, 107, 107, 0.4);
        }

        .status-indicator {
            height: 8px;
            width: 8px;
            border-radius: 50%;
            display: inline-block;
            background-color: #ccc;
            margin-right: 8px;
            transition: all 0.3s ease;
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 1002;
        }

        .status-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 12px #4CAF50;
            animation: statusPulse 2s infinite;
        }

        .audio-meter {
            position: fixed;
            top: 26px;
            right: 50px;
            height: 16px;
            width: 120px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            z-index: 1002;
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        .audio-meter .bar {
            height: 100%;
            width: 6%;
            background: linear-gradient(90deg, #8bc34a, #4caf50);
            transition: width 120ms ease, background 180ms ease;
        }

        .audio-meter.level-low .bar {
            background: linear-gradient(90deg, #cddc39, #9e9d24);
        }

        .audio-meter.level-muted .bar {
            background: linear-gradient(90deg, #f44336, #d32f2f);
        }

        .audio-meter.level-high .bar {
            background: linear-gradient(90deg, #ff9800, #f57c00);
        }

        .highlight {
            background-color: #90EE90;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 500;
            color: #333;
        }

        .badge-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
            font-size: 0.78rem;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.06);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.05);
            font-weight: 600;
            text-transform: none;
            letter-spacing: 0.01em;
        }

        .badge-question { background: rgba(30, 136, 229, 0.12); border-color: rgba(30, 136, 229, 0.35); color: #1e88e5; }
        .badge-command { background: rgba(255, 112, 67, 0.14); border-color: rgba(255, 112, 67, 0.35); color: #f4511e; }
        .badge-topic { background: rgba(0, 200, 83, 0.14); border-color: rgba(0, 200, 83, 0.35); color: #00c853; }
        .badge-thought { background: rgba(156, 39, 176, 0.12); border-color: rgba(156, 39, 176, 0.35); color: #9c27b0; }
        .badge-note { background: rgba(255, 202, 40, 0.18); border-color: rgba(255, 202, 40, 0.45); color: #c17900; }
        .badge-task { background: rgba(3, 169, 244, 0.16); border-color: rgba(3, 169, 244, 0.35); color: #0288d1; }
        .badge-idea { background: rgba(255, 235, 59, 0.26); border-color: rgba(255, 235, 59, 0.55); color: #8a7300; }

        .confidence-dot {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #666;
        }

        .confidence-dot::before {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08);
        }

        .conf-high::before { background: #4CAF50; box-shadow: 0 0 8px rgba(76, 175, 80, 0.4); }
        .conf-mid::before { background: #FFC107; box-shadow: 0 0 8px rgba(255, 193, 7, 0.35); }
        .conf-low::before { background: #F44336; box-shadow: 0 0 8px rgba(244, 67, 54, 0.35); }

        .line-reviewed { border-left-color: #FFC107; background: rgba(255, 193, 7, 0.08); }

        @keyframes pulse {
            0% {
                box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            }
            50% {
                box-shadow: 0 4px 25px rgba(255, 107, 107, 0.6);
            }
            100% {
                box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            }
        }

        @keyframes statusPulse {
            0% {
                box-shadow: 0 0 12px #4CAF50;
            }
            50% {
                box-shadow: 0 0 20px #4CAF50, 0 0 30px #4CAF50;
            }
            100% {
                box-shadow: 0 0 12px #4CAF50;
            }
        }

        @media (max-width: 768px) {
            .vox-container {
                padding: 1rem;
            }

            .mic-button {
                width: 70px;
                height: 70px;
            }

            .mic-icon {
                width: 28px;
                height: 28px;
            }

            .transcription-display {
                max-width: 95%;
                bottom: 8%;
            }

            .transcription-lines {
                font-size: 0.9rem;
                padding: 15px 20px;
                min-width: 250px;
                max-height: 150px;
            }

            .transcription-line {
                padding: 6px 10px;
                margin-bottom: 6px;
            }

            .save-controls {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .save-button,
            .clear-button {
                width: 140px;
            }

            .status-indicator {
                top: 20px;
                right: 20px;
            }

            .sine-wave {
                height: 150px;
                bottom: 15%;
            }
        }

        @media (max-width: 480px) {
            .mic-button {
                width: 60px;
                height: 60px;
            }

            .mic-icon {
                width: 24px;
                height: 24px;
            }

            .transcription-display {
                bottom: 5%;
            }

            .transcription-lines {
                font-size: 0.85rem;
                padding: 12px 15px;
                min-width: 200px;
                max-height: 120px;
            }

            .transcription-line {
                padding: 5px 8px;
                margin-bottom: 5px;
            }

            .save-button,
            .clear-button {
                font-size: 0.8rem;
                padding: 8px 16px;
                width: 120px;
            }

            .sine-wave {
                height: 120px;
                bottom: 10%;
            }
        }
    </style>
</head>
<body>
    <div class="hamburger" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <div class="overlay" onclick="closeMenu()"></div>

    <nav class="sidebar">
        <a href="../index.html" class="menu-item">Início</a>
        <a href="../syrax.html" class="menu-item">SyraX</a>
        <a href="../lunagpt.html" class="menu-item">LunaGPT</a>
        <a href="../sobre.html" class="menu-item">Sobre</a>
        <a href="../contato.html" class="menu-item">Contato</a>
        <a href="../colabs/colabs.html" class="menu-item">Colabs</a>
        <div class="menu-footer">Desenvolvido pela @SyraDevOps</div>
    </nav>

    <div class="wave-container">
        <div class="sine-wave">
            <svg viewBox="0 0 1200 200" xmlns="http://www.w3.org/2000/svg">
                <path d="M0,100 Q150,50 300,100 T600,100 T900,100 T1200,100 T1500,100 T1800,100 T2100,100 T2400,100 T2700,100 T3000,100" stroke-linecap="round"/>
            </svg>
        </div>
    </div>

    <div class="vox-container">
        <button class="mic-button" onclick="toggleVoiceRecording()">
            <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 1C10.3431 1 9 2.34315 9 4V12C9 13.6569 10.3431 15 12 15C13.6569 15 15 13.6569 15 12V4C15 2.34315 13.6569 1 12 1Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M19 10V12C19 16.4183 15.4183 20 11 20C6.58172 20 3 16.4183 3 12V10" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 20V23" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 23H16" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
    </div>

    <div class="status-indicator" id="statusIndicator"></div>
    <div class="audio-meter" id="audioMeter" aria-label="Nível de áudio">
        <div class="bar"></div>
    </div>

    <div class="transcription-display" id="transcriptionDisplay">
        <div class="transcription-lines" id="transcriptionLines">
            <div class="empty-state">Clique no microfone para começar a falar...</div>
        </div>
        <div class="save-controls" id="saveControls" style="display: none;">
            <button class="save-button" onclick="saveTranscription()">Salvar TXT</button>
            <button class="clear-button" onclick="clearTranscription()">Limpar</button>
        </div>
    </div>

    <script src="../script.js"></script>
    <script>
        const micButton = document.querySelector('.mic-button');
        const statusIndicator = document.getElementById('statusIndicator');
        const transcriptionLines = document.getElementById('transcriptionLines');
        const saveControls = document.getElementById('saveControls');
        const audioMeter = document.getElementById('audioMeter');
        const audioBar = audioMeter ? audioMeter.querySelector('.bar') : null;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const MAX_ROLLBACK_WORDS = 5;
        const MIN_WORDS_FOR_SAVE = 3;
        const SAVE_DEBOUNCE_MS = 1500;
        const FREEZE_MS = 1500;
        const SILENCE_THRESHOLD = 0.02;
        const SILENCE_MS = 1200;

        const commandWords = ['salvar', 'limpar', 'parar', 'pausar', 'continuar', 'gravar'];
        const questionWords = ['por que', 'porque', 'por quê', 'quando', 'como', 'onde', 'quem'];
        const connectors = ['então', 'mas', 'porém', 'contudo', 'logo', 'portanto'];

        const loadDictionary = () => {
            try {
                const stored = localStorage.getItem('voxDictionary');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                return [];
            }
        };

        const saveDictionary = dict => {
            try {
                localStorage.setItem('voxDictionary', JSON.stringify(dict.slice(0, 200)));
            } catch (e) {
                // ignore quota
            }
        };

        const voxState = {
            recognition: null,
            isListening: false,
            committedWords: [],
            entries: [],
            entryWordCounts: [],
            entryNodes: [],
            entryMeta: [],
            rawTranscriptions: [],
            interimNode: null,
            lastSavedNormalized: '',
            lastSavedAt: 0,
            sessionStart: null,
            audioContext: null,
            analyser: null,
            audioRAF: null,
            silenceStartedAt: null,
            silenceRecently: false,
            lastEventAt: 0,
            lastRms: 0,
            dictionary: loadDictionary()
        };

        const semanticState = {
            frequencies: {}
        };

        const normalizeTranscript = text => {
            return text
                .toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/[^\w\s]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        };

        const escapeHtml = text => text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');

        const extractWords = text => text.split(/\s+/).filter(Boolean);

        const applyAutoPunctuation = (text, context) => {
            const trimmed = text.trim();
            if (!trimmed) {
                return '';
            }

            const lower = normalizeTranscript(trimmed);
            const endsWithPunct = /[.!?…:]$/.test(trimmed);
            const pause = context?.pause || 0;
            const silence = context?.silenceRecently;
            const hasQuestionCue = questionWords.some(q => lower.includes(q));

            if (endsWithPunct) {
                return trimmed;
            }

            if (hasQuestionCue) {
                return `${trimmed}?`;
            }

            if (silence || pause > 1200) {
                return `${trimmed}.`;
            }

            if (pause > 700) {
                return `${trimmed},`;
            }

            return trimmed;
        };

        const polishSentence = text => {
            if (!text) return '';
            let t = text.replace(/\s+/g, ' ').trim();
            // remove repetições imediatas
            t = t.replace(/(\b\w+\b)\s+\1/gi, '$1');
            // capitaliza início
            t = t.charAt(0).toUpperCase() + t.slice(1);
            // garante pontuação final
            if (!/[.!?…:]$/.test(t)) {
                t += '.';
            }
            return t;
        };

        const computeRollback = (segmentWords, committedWords) => {
            let prefix = 0;
            const len = Math.min(segmentWords.length, committedWords.length);
            while (prefix < len && segmentWords[prefix].toLowerCase() === committedWords[prefix].toLowerCase()) {
                prefix++;
            }
            const minPrefix = Math.max(0, committedWords.length - MAX_ROLLBACK_WORDS);
            return Math.max(prefix, minPrefix);
        };

        const detectBadges = text => {
            const norm = normalizeTranscript(text);
            const badges = [];
            if (questionWords.some(q => norm.includes(q)) || /\?$/.test(text.trim())) {
                badges.push('question');
            }
            if (commandWords.some(cmd => norm.includes(cmd))) {
                badges.push('command');
            }
            if (connectors.some(c => norm.startsWith(c))) {
                badges.push('topic');
            }
            if (/\b(tarefa|to\s?do|task)\b/i.test(text)) {
                badges.push('task');
            }
            if (/\b(ideia|idea|inspira)\b/i.test(text)) {
                badges.push('idea');
            }
            if (/\b(nota|anota|registrar)\b/i.test(text)) {
                badges.push('note');
            }
            if (/\b(tipo|hum|é\.{0,2}|é\s+que)\b/i.test(text) || /\.\.\.$/.test(text.trim())) {
                badges.push('thought');
            }
            return badges;
        };

        const confidenceLevel = score => {
            if (score >= 0.7) return 'conf-high';
            if (score >= 0.4) return 'conf-mid';
            return 'conf-low';
        };

        const deriveConfidenceScore = (speechConfidence, rms) => {
            const conf = typeof speechConfidence === 'number' ? speechConfidence : 0.55;
            const volume = Math.min(1, Math.max(0, rms * 2.5));
            const blend = (conf * 0.65) + (volume * 0.35);
            return Math.min(1, Math.max(0.15, blend));
        };

        const freezeOldEntries = now => {
            voxState.entryMeta.forEach(meta => {
                if (!meta) return;
                if (!meta.frozenAt && now - meta.createdAt >= FREEZE_MS) {
                    meta.frozenAt = now;
                }
            });
        };

        const recomputeFrequencies = () => {
            const freq = {};
            voxState.entries.forEach(text => {
                extractWords(normalizeTranscript(text)).forEach(word => {
                    freq[word] = (freq[word] || 0) + 1;
                    if (!voxState.dictionary.includes(word) && word.length >= 6) {
                        voxState.dictionary.push(word);
                    }
                });
            });
            semanticState.frequencies = freq;
            saveDictionary(voxState.dictionary);
        };

        const refreshHighlights = () => {
            voxState.entryNodes.forEach((node, index) => {
                if (node) {
                    node.innerHTML = buildLineHtml(voxState.entries[index], voxState.entryMeta[index]);
                    node.classList.toggle('line-reviewed', !!voxState.entryMeta[index]?.reviewed);
                }
            });
        };

        const shouldHighlightWord = word => {
            const norm = normalizeTranscript(word);
            const freq = semanticState.frequencies[norm] || 0;
            const isCommand = commandWords.includes(norm);
            const inDictionary = voxState.dictionary.includes(norm);
            const isLong = norm.length >= 9;
            const hasNumber = /\d/.test(word);
            const isRepeated = freq >= 3;
            return isCommand || isLong || hasNumber || isRepeated || (!freq && !inDictionary && norm.length >= 6);
        };

        const highlightSemantic = text => {
            const tokens = text.split(/(\s+)/);
            return tokens.map(token => {
                if (/^\s+$/.test(token)) {
                    return token;
                }
                if (shouldHighlightWord(token)) {
                    return `<span class="highlight">${escapeHtml(token)}</span>`;
                }
                return escapeHtml(token);
            }).join('');
        };

        const buildBadgesHtml = badges => {
            if (!badges || !badges.length) return '';
            const mapClass = {
                question: 'badge-question',
                command: 'badge-command',
                topic: 'badge-topic',
                thought: 'badge-thought',
                note: 'badge-note',
                task: 'badge-task',
                idea: 'badge-idea'
            };
            return `<div class="badge-row">${badges.map(b => `<span class="badge ${mapClass[b] || ''}">${b}</span>`).join('')}</div>`;
        };

        const buildLineHtml = (text, meta) => {
            const confClass = confidenceLevel(meta?.confidence || 0.5);
            const confLabel = meta?.confidence ? `${Math.round(meta.confidence * 100)}%` : '';
            const confidenceHtml = `<span class="confidence-dot ${confClass}">${confLabel}</span>`;
            const badgesHtml = buildBadgesHtml(meta?.badges || []);
            return `${highlightSemantic(text)}${badgesHtml ? badgesHtml : ''}<div class="badge-row">${confidenceHtml}</div>`;
        };

        const updateEmptyStateWhenNeeded = () => {
            if (!voxState.entries.length && !voxState.interimNode) {
                const message = voxState.isListening ? 'Escutando...' : 'Clique no microfone para começar a falar...';
                transcriptionLines.innerHTML = `<div class="empty-state">${message}</div>`;
                saveControls.style.display = 'none';
            }
        };

        const trimStoredEntriesTo = wordCount => {
            let total = voxState.entryWordCounts.reduce((sum, count) => sum + count, 0);

            while (total > wordCount && voxState.entries.length) {
                const lastIndex = voxState.entries.length - 1;
                const wordsInEntry = voxState.entryWordCounts[lastIndex];
                const removeCount = Math.min(wordsInEntry, total - wordCount);

                if (removeCount === wordsInEntry) {
                    const node = voxState.entryNodes[lastIndex];
                    if (node) {
                        node.remove();
                    }
                    voxState.entries.pop();
                    voxState.entryWordCounts.pop();
                    voxState.entryNodes.pop();
                    voxState.entryMeta.pop();
                } else {
                    const words = voxState.entries[lastIndex].split(/\s+/);
                    const updatedWords = words.slice(0, words.length - removeCount);
                    voxState.entries[lastIndex] = updatedWords.join(' ');
                    voxState.entryWordCounts[lastIndex] -= removeCount;
                    const node = voxState.entryNodes[lastIndex];
                    if (node) {
                        node.innerHTML = buildLineHtml(voxState.entries[lastIndex], voxState.entryMeta[lastIndex]);
                    }
                }

                total -= removeCount;
            }

            voxState.committedWords = voxState.committedWords.slice(0, wordCount);
            recomputeFrequencies();
            refreshHighlights();
            updateEmptyStateWhenNeeded();
        };

        const mergeOrAppendEntry = (newWords, meta, now) => {
            const newText = newWords.join(' ').trim();
            if (!newText) {
                return;
            }

            if (!voxState.entries.length) {
                transcriptionLines.innerHTML = '';
            }

            const lastIndex = voxState.entries.length - 1;
            const lastMeta = voxState.entryMeta[lastIndex];
            const startWithConnector = connectors.includes(normalizeTranscript(newWords[0] || ''));
            const canMerge =
                lastIndex >= 0 &&
                voxState.entryWordCounts[lastIndex] > 0 &&
                !/[.!?…:]$/.test(voxState.entries[lastIndex].trim()) &&
                voxState.entryWordCounts[lastIndex] + newWords.length <= 40 &&
                newWords.length <= 6 &&
                !startWithConnector &&
                !(lastMeta && lastMeta.frozenAt);

            if (canMerge) {
                if (!voxState.entryMeta[lastIndex]) {
                    voxState.entryMeta[lastIndex] = { createdAt: now, confidence: meta.confidence, badges: [...(meta.badges || [])] };
                }
                voxState.entries[lastIndex] = `${voxState.entries[lastIndex]} ${newText}`.trim();
                voxState.entryWordCounts[lastIndex] += newWords.length;
                if (lastMeta) {
                    lastMeta.confidence = Math.max(lastMeta.confidence || 0, meta.confidence || 0);
                    lastMeta.badges = Array.from(new Set([...(lastMeta.badges || []), ...(meta.badges || [])]));
                    lastMeta.reviewed = lastMeta.reviewed || meta.reviewed;
                }
                const node = voxState.entryNodes[lastIndex];
                if (node) {
                    node.innerHTML = buildLineHtml(voxState.entries[lastIndex], voxState.entryMeta[lastIndex]);
                    if (lastMeta?.reviewed) {
                        node.classList.add('line-reviewed');
                    }
                }
            } else {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'transcription-line';
                if (meta?.reviewed) {
                    lineDiv.classList.add('line-reviewed');
                }
                lineDiv.innerHTML = buildLineHtml(newText, meta);
                transcriptionLines.appendChild(lineDiv);

                voxState.entryNodes.push(lineDiv);
                voxState.entries.push(newText);
                voxState.entryWordCounts.push(newWords.length);
                voxState.entryMeta.push(meta);
            }

            transcriptionLines.scrollTop = transcriptionLines.scrollHeight;
            saveControls.style.display = 'flex';
            recomputeFrequencies();
            refreshHighlights();
            freezeOldEntries(now);
        };

        const commitSegment = (cleanedText, meta, now) => {
            if (voxState.interimNode) {
                voxState.interimNode.remove();
                voxState.interimNode = null;
            }

            const segmentWords = extractWords(cleanedText);
            if (!segmentWords.length) {
                updateEmptyStateWhenNeeded();
                return;
            }

            const prefixLength = computeRollback(segmentWords, voxState.committedWords);
            if (prefixLength < voxState.committedWords.length) {
                trimStoredEntriesTo(prefixLength);
            }

            const newWords = segmentWords.slice(prefixLength);
            mergeOrAppendEntry(newWords, meta, now);
            voxState.committedWords = segmentWords.slice(0, prefixLength + newWords.length);
        };

        const shouldSaveFinal = (text, now) => {
            const normalized = normalizeTranscript(text);
            const words = extractWords(normalized);
            const enoughWords = words.length >= MIN_WORDS_FOR_SAVE;
            const changed = normalized && normalized !== voxState.lastSavedNormalized;
            const spacedOut = now - voxState.lastSavedAt >= SAVE_DEBOUNCE_MS;
            return enoughWords && changed && spacedOut;
        };

        const formatTimestamp = (start, now) => {
            const elapsedSec = Math.floor((now - start) / 1000);
            const minutes = Math.floor(elapsedSec / 60);
            const seconds = elapsedSec % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        const handleFinalSegment = (text, now, confidenceHint, pauseSinceLast) => {
            const cleaned = text.replace(/\s+/g, ' ').trim();
            if (!cleaned) {
                return;
            }

            if (voxState.sessionStart === null) {
                voxState.sessionStart = now;
            }

            const withPunctuation = applyAutoPunctuation(cleaned, { pause: pauseSinceLast, silenceRecently: voxState.silenceRecently });
            const polished = polishSentence(withPunctuation);
            const badges = detectBadges(polished);
            const confidenceScore = deriveConfidenceScore(confidenceHint, voxState.lastRms || 0);
            const meta = {
                createdAt: now,
                frozenAt: null,
                confidence: confidenceScore,
                badges,
                reviewed: true
            };

            if (shouldSaveFinal(polished, now)) {
                const timestamp = formatTimestamp(voxState.sessionStart, now);
                voxState.rawTranscriptions.push(`[${timestamp}] ${polished}`);
                voxState.lastSavedNormalized = normalizeTranscript(polished);
                voxState.lastSavedAt = now;
            }

            commitSegment(polished, meta, now);
        };

        const renderInterim = text => {
            const interim = text.trim();
            if (interim) {
                if (!voxState.interimNode) {
                    voxState.interimNode = document.createElement('div');
                    voxState.interimNode.className = 'transcription-line interim';
                    transcriptionLines.appendChild(voxState.interimNode);
                }
                voxState.interimNode.innerHTML = highlightSemantic(interim);
                transcriptionLines.scrollTop = transcriptionLines.scrollHeight;
            } else if (voxState.interimNode) {
                voxState.interimNode.remove();
                voxState.interimNode = null;
                updateEmptyStateWhenNeeded();
            }
        };

        const initializeSpeechRecognition = () => {
            if (voxState.recognition || !SpeechRecognition) {
                if (!voxState.recognition && !SpeechRecognition) {
                    transcriptionLines.innerHTML = '<div class="empty-state" style="color: #ff6b6b;">Reconhecimento de voz não suportado neste navegador</div>';
                }
                return !!voxState.recognition;
            }

            const recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'pt-BR';

            recognition.onstart = () => {
                statusIndicator.classList.add('active');
                if (!voxState.entries.length && !voxState.interimNode) {
                    transcriptionLines.innerHTML = '<div class="empty-state">Escutando...</div>';
                }
                transcriptionLines.classList.add('visible');
            };

            recognition.onresult = event => {
                let interimTranscript = '';
                const now = Date.now();
                const pause = voxState.lastEventAt ? now - voxState.lastEventAt : 0;
                voxState.lastEventAt = now;

                if (voxState.sessionStart === null) {
                    voxState.sessionStart = now;
                }

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const transcript = result[0].transcript.trim();
                    const confidenceHint = typeof result[0].confidence === 'number' ? result[0].confidence : undefined;

                    if (result.isFinal && transcript) {
                        handleFinalSegment(transcript, now, confidenceHint, pause);
                    } else if (!result.isFinal) {
                        interimTranscript += ` ${transcript}`;
                    }
                }

                renderInterim(interimTranscript);
            };

            recognition.onerror = event => {
                console.error('Erro no reconhecimento de voz:', event.error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'transcription-line';
                errorDiv.style.color = '#ff6b6b';
                errorDiv.style.borderLeftColor = '#ff6b6b';
                errorDiv.textContent = `Erro: ${event.error}`;
                transcriptionLines.appendChild(errorDiv);
                transcriptionLines.scrollTop = transcriptionLines.scrollHeight;
                stopRecognition();
            };

            recognition.onend = () => {
                if (voxState.interimNode) {
                    voxState.interimNode.remove();
                    voxState.interimNode = null;
                }

                if (voxState.isListening) {
                    setTimeout(() => {
                        if (voxState.isListening && voxState.recognition) {
                            try {
                                voxState.recognition.start();
                            } catch (error) {
                                console.warn('Falha ao reiniciar reconhecimento:', error);
                                stopRecognition();
                            }
                        }
                    }, 250);
                } else {
                    statusIndicator.classList.remove('active');
                    updateEmptyStateWhenNeeded();
                }
            };

            voxState.recognition = recognition;
            return true;
        };

        const startRecognition = () => {
            if (!initializeSpeechRecognition()) {
                return;
            }
            if (voxState.isListening) {
                return;
            }

            try {
                if (voxState.sessionStart === null) {
                    voxState.sessionStart = Date.now();
                    voxState.lastSavedAt = 0;
                    voxState.lastSavedNormalized = '';
                }
                voxState.recognition.start();
                voxState.isListening = true;
                micButton.classList.add('recording');
                statusIndicator.classList.add('active');
            } catch (error) {
                console.error('Não foi possível iniciar o reconhecimento:', error);
            }
        };

        const stopRecognition = () => {
            if (!voxState.isListening) {
                return;
            }

            voxState.isListening = false;

            if (voxState.recognition) {
                try {
                    voxState.recognition.stop();
                } catch (error) {
                    console.warn('Falha ao parar reconhecimento:', error);
                }
            }

            micButton.classList.remove('recording');
            statusIndicator.classList.remove('active');

            if (voxState.interimNode) {
                voxState.interimNode.remove();
                voxState.interimNode = null;
            }

            if (!voxState.entries.length) {
                transcriptionLines.classList.remove('visible');
                updateEmptyStateWhenNeeded();
            }
        };

        const toggleVoiceRecording = () => {
            if (voxState.isListening) {
                stopRecognition();
            } else {
                startRecognition();
            }
        };

        const saveTranscription = () => {
            if (!voxState.rawTranscriptions.length) {
                alert('Não há transcrições para salvar');
                return;
            }

            const now = new Date();
            const timestamp = now.toLocaleString('pt-BR').replace(/[/:]/g, '-');
            const filename = `transcricao-vox-${timestamp}.txt`;

            const header = `Transcrição Vox - SyraDevOps\nData: ${now.toLocaleString('pt-BR')}\nTotal de frases: ${voxState.rawTranscriptions.length}\n${'='.repeat(50)}\n\n`;
            const body = voxState.rawTranscriptions.join('\n\n');
            const blob = new Blob([header + body], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            const successDiv = document.createElement('div');
            successDiv.className = 'transcription-line';
            successDiv.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
            successDiv.style.borderLeftColor = '#4CAF50';
            successDiv.style.color = '#4CAF50';
            successDiv.textContent = 'Arquivo salvo com sucesso!';
            transcriptionLines.appendChild(successDiv);
            transcriptionLines.scrollTop = transcriptionLines.scrollHeight;

            setTimeout(() => {
                successDiv.remove();
                updateEmptyStateWhenNeeded();
            }, 3000);
        };

        const clearTranscription = () => {
            voxState.entries = [];
            voxState.rawTranscriptions = [];
            voxState.entryWordCounts = [];
            voxState.entryMeta = [];
            voxState.committedWords = [];
            voxState.entryNodes.forEach(node => node.remove());
            voxState.entryNodes = [];
            transcriptionLines.innerHTML = '';
            voxState.sessionStart = null;
            voxState.lastSavedAt = 0;
            voxState.lastSavedNormalized = '';
            voxState.silenceStartedAt = null;
            voxState.silenceRecently = false;
            voxState.lastEventAt = 0;
            voxState.lastRms = 0;

            if (voxState.interimNode) {
                voxState.interimNode.remove();
                voxState.interimNode = null;
            }

            saveControls.style.display = 'none';
            if (voxState.isListening) {
                transcriptionLines.classList.add('visible');
            } else {
                transcriptionLines.classList.remove('visible');
            }

            recomputeFrequencies();
            updateEmptyStateWhenNeeded();
        };

        const updateAudioMeter = rms => {
            if (!audioMeter || !audioBar) {
                return;
            }

            voxState.lastRms = rms;

            const clamped = Math.min(1, Math.max(0, rms * 3.5));
            const width = Math.max(4, Math.round(clamped * 100));
            audioBar.style.width = `${width}%`;

            audioMeter.classList.remove('level-muted', 'level-low', 'level-high');
            if (clamped < 0.05) {
                audioMeter.classList.add('level-muted');
            } else if (clamped < 0.12) {
                audioMeter.classList.add('level-low');
            } else if (clamped > 0.9) {
                audioMeter.classList.add('level-high');
            }
        };

        const setupAudioMeter = async () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || voxState.audioContext) {
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = context.createAnalyser();
                analyser.fftSize = 2048;
                const source = context.createMediaStreamSource(stream);
                source.connect(analyser);

                voxState.audioContext = context;
                voxState.analyser = analyser;

                const data = new Uint8Array(analyser.fftSize);

                const loop = () => {
                    analyser.getByteTimeDomainData(data);
                    let sum = 0;
                    for (let i = 0; i < data.length; i++) {
                        const v = (data[i] - 128) / 128;
                        sum += v * v;
                    }
                    const rms = Math.sqrt(sum / data.length);
                    updateAudioMeter(rms);

                    const now = performance.now();
                    if (rms < SILENCE_THRESHOLD) {
                        if (!voxState.silenceStartedAt) {
                            voxState.silenceStartedAt = now;
                        }
                        if (now - voxState.silenceStartedAt > SILENCE_MS) {
                            voxState.silenceRecently = true;
                        }
                    } else {
                        voxState.silenceStartedAt = null;
                        voxState.silenceRecently = false;
                    }

                    voxState.audioRAF = requestAnimationFrame(loop);
                };

                loop();
            } catch (err) {
                console.warn('Permissão de microfone negada para medidor:', err);
                updateAudioMeter(0);
            }
        };

        // expõe handlers para o HTML inline
        window.toggleVoiceRecording = toggleVoiceRecording;
        window.saveTranscription = saveTranscription;
        window.clearTranscription = clearTranscription;

        window.addEventListener('load', () => {
            if (!SpeechRecognition) {
                transcriptionLines.innerHTML = '<div class="empty-state" style="color: #ff6b6b;">Reconhecimento de voz não suportado neste navegador</div>';
                return;
            }

            initializeSpeechRecognition();
            setupAudioMeter();

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch(err => {
                        console.warn('Permissão de microfone negada:', err);
                        transcriptionLines.innerHTML = '<div class="empty-state" style="color: #ff6b6b;">Permissão de microfone necessária</div>';
                    });
            }
        });
    </script>
</body>
</html>
