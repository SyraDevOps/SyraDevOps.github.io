<!DOCTYPE html>
<html lang="pt-BR">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>LunaGPT - SyraDevOps</title>
	<link rel="stylesheet" href="style.css">
	<style>
		body {
			background: #ffffff;
			color: #1f2937;
			min-height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			margin: 0;
			padding: 0;
		}

		.search-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 2rem;
			max-width: 600px;
			width: 100%;
			padding: 2rem;
		}

		.search-bar {
			width: 100%;
			max-width: 500px;
			position: relative;
		}

		.search-input {
			width: 100%;
			padding: 1.2rem 2rem;
			font-size: 1.1rem;
			border: 2px solid #e5e7eb;
			border-radius: 50px;
			background: #ffffff;
			color: #374151;
			outline: none;
			transition: all 0.3s ease;
			box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
		}

		.search-input:focus {
			border-color: #3b82f6;
			box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
		}

		.search-results {
			margin-top: 3rem;
			max-width: 1200px;
			width: 100%;
		}

		.map-section {
			margin-bottom: 3rem;
			opacity: 0;
			transform: translateY(30px);
			transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
		}

		.map-section.visible {
			opacity: 1;
			transform: translateY(0);
		}

		.map-container {
			background: #ffffff;
			border-radius: 20px;
			padding: 2rem;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
			border: 1px solid #e5e7eb;
			position: relative;
			overflow: hidden;
		}

		.map-container::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 4px;
			background: linear-gradient(90deg, #10b981, #059669, #10b981);
			background-size: 200% 100%;
			animation: shimmer 2s ease-in-out infinite;
		}

		.map-title {
			font-size: 1.5rem;
			font-weight: 600;
			color: #1f2937;
			margin-bottom: 1.5rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.map-frame {
			width: 100%;
			height: 400px;
			border: none;
			border-radius: 16px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
		}

		.results-columns {
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
			margin-top: 2rem;
			max-width: 800px;
		}

		.api-column {
			display: flex;
			flex-direction: column;
			gap: 1rem;
		}

		.column-header {
			font-size: 0.9rem;
			font-weight: 500;
			color: #666666;
			margin-bottom: 0.5rem;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			border-bottom: 1px solid #e0e0e0;
			padding-bottom: 0.25rem;
		}

		.result-item {
			padding: 1rem 0;
			border-bottom: 1px solid #f0f0f0;
			transition: all 0.2s ease;
			opacity: 0;
			transform: translateY(20px);
		}

		.result-item.visible {
			opacity: 1;
			transform: translateY(0);
		}

		.result-item:hover {
			background: rgba(0, 0, 0, 0.02);
			padding-left: 0.5rem;
			margin-left: -0.5rem;
			margin-right: -0.5rem;
			padding-right: 0.5rem;
		}

		.result-title {
			font-size: 1.1rem;
			font-weight: 400;
			color: #1a1a1a;
			line-height: 1.4;
			margin-bottom: 0.25rem;
		}

		.result-link {
			color: #0066cc;
			text-decoration: none;
			position: relative;
			font-size: 0.9rem;
			display: inline-block;
			margin-bottom: 0.5rem;
		}

		.result-link::after {
			content: '';
			position: absolute;
			bottom: -2px;
			left: 0;
			width: 0;
			height: 1px;
			background: #0066cc;
			transition: width 0.3s ease;
		}

		.result-link:hover::after {
			width: 100%;
		}

		.result-description {
			color: #666666;
			line-height: 1.5;
			font-size: 0.95rem;
			margin-bottom: 0.5rem;
		}

		.result-source {
			color: #999999;
			font-size: 0.8rem;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		@media (max-width: 768px) {
			.results-columns {
				grid-template-columns: 1fr;
				gap: 1.5rem;
			}

			.column-header {
				position: static;
			}

			.map-frame {
				height: 300px;
			}
		}

		.loading {
			text-align: center;
			padding: 3rem;
			color: #6b7280;
			font-size: 1.1rem;
		}

		.loading-spinner {
			display: inline-block;
			width: 24px;
			height: 24px;
			border: 3px solid #e5e7eb;
			border-top: 3px solid #3b82f6;
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin-right: 0.5rem;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.error {
			background: #fef2f2;
			border: 1px solid #fecaca;
			color: #dc2626;
			padding: 1rem;
			border-radius: 12px;
			text-align: center;
			margin: 1rem 0;
		}

		.no-results {
			text-align: center;
			padding: 3rem;
			color: #9ca3af;
			font-size: 1.1rem;
		}

		.search-input::placeholder {
			color: #9ca3af;
			font-style: italic;
		}

		.typing-animation {
			position: absolute;
			right: 1.5rem;
			top: 50%;
			transform: translateY(-50%);
			font-size: 1.1rem;
			color: #6b7280;
			font-weight: 500;
			letter-spacing: 1px;
		}

		.cursor {
			animation: blink 1s infinite;
		}

		@keyframes blink {
			0%, 50% { opacity: 1; }
			51%, 100% { opacity: 0; }
		}

		.search-subtitle {
			color: #6b7280;
			font-size: 0.95rem;
			text-align: center;
			line-height: 1.6;
			max-width: 400px;
		}

		.search-title {
			color: #1f2937;
			font-size: 2rem;
			font-weight: 600;
			text-align: center;
			margin-bottom: 0.5rem;
		}

		@media (max-width: 640px) {
			.search-container {
				padding: 1rem;
			}

			.search-title {
				font-size: 1.8rem;
			}

			.search-input {
				font-size: 1rem;
				padding: 1rem 1.5rem;
			}
		}
	</style>
</head>
<body>
	<div class="hamburger" onclick="toggleMenu()">
		<span></span>
		<span></span>
		<span></span>
	</div>

	<div class="overlay" onclick="closeMenu()"></div>

	<nav class="sidebar">
		<a href="index.html" class="menu-item">Início</a>
		<a href="syrax.html" class="menu-item">SyraX</a>
		<a href="lunagpt.html" class="menu-item">LunaGPT</a>
		<a href="sobre.html" class="menu-item">Sobre</a>
		<a href="contato.html" class="menu-item">Contato</a>
		<a href="colabs/colabs.html" class="menu-item">Colabs</a>
		<div class="menu-footer">
			Desenvolvido pela @SyraDevOps
		</div>
	</nav>

	<main class="search-container">
		<div>
			<h1 class="search-title">LunaGPT</h1>
			<p class="search-subtitle">Sua assistente inteligente está pronta para ajudar</p>
		</div>

		<div class="search-bar">
			<form onsubmit="performSearch(event)">
				<input
					type="text"
					class="search-input"
					id="search-query"
					placeholder="Digite sua pergunta..."
					required
				>
			</form>
			<div class="typing-animation" id="typing-animation">
				<span id="dots">...</span>
			</div>
		</div>

		<div class="search-results" id="search-results">
			<!-- Resultados aparecerão aqui -->
		</div>
	</main>

	<script src="script.js"></script>
	<script>
		let searchInProgress = false;
		let observer;

		document.addEventListener('DOMContentLoaded', function() {
			const dotsElement = document.getElementById('dots');
			const typingAnimation = document.getElementById('typing-animation');
			const searchInput = document.getElementById('search-query');
			const texts = ['...', '..', '.', ''];
			let currentIndex = 0;
			let dotsInterval;

			function animateDots() {
				dotsElement.textContent = texts[currentIndex];
				currentIndex = (currentIndex + 1) % texts.length;
			}

			// Iniciar animação
			dotsInterval = setInterval(animateDots, 500);

			// Ocultar animação quando usuário começar a digitar
			searchInput.addEventListener('focus', function() {
				typingAnimation.style.display = 'none';
			});

			searchInput.addEventListener('blur', function() {
				if (!searchInput.value.trim()) {
					typingAnimation.style.display = 'block';
				}
			});

			// Configurar observer para animações de scroll
			setupScrollObserver();
		});

		function setupScrollObserver() {
			observer = new IntersectionObserver((entries) => {
				entries.forEach(entry => {
					if (entry.isIntersecting) {
						entry.target.classList.add('visible');
					}
				});
			}, {
				threshold: 0.1,
				rootMargin: '0px 0px -50px 0px'
			});
		}

		async function performSearch(event) {
			event.preventDefault();
			
			if (searchInProgress) return;
			
			const query = document.getElementById('search-query').value.trim();
			if (!query) return;

			searchInProgress = true;
			const resultsContainer = document.getElementById('search-results');
			
			// Mostrar loading
			resultsContainer.innerHTML = `
				<div class="loading">
					<div class="loading-spinner"></div>
					Pesquisando em múltiplas fontes...
				</div>
			`;

			try {
				// Executar todas as pesquisas em paralelo
				const [mapResults, wikipediaResults, redditResults, duckduckgoResults, dictionaryResults] = await Promise.allSettled([
					searchMaps(query),
					searchWikipedia(query),
					searchReddit(query),
					searchDuckDuckGo(query),
					searchDictionary(query)
				]);

				// Organizar resultados por API
				const resultsByAPI = {
					maps: mapResults.status === 'fulfilled' ? mapResults.value : [],
					wikipedia: wikipediaResults.status === 'fulfilled' ? wikipediaResults.value : [],
					reddit: redditResults.status === 'fulfilled' ? redditResults.value : [],
					duckduckgo: duckduckgoResults.status === 'fulfilled' ? duckduckgoResults.value : [],
					dictionary: dictionaryResults.status === 'fulfilled' ? dictionaryResults.value : []
				};

				displayResults(resultsByAPI);
			} catch (error) {
				resultsContainer.innerHTML = '<div class="error">❌ Erro ao realizar pesquisa. Tente novamente.</div>';
			} finally {
				searchInProgress = false;
			}
		}

		function displayResults(resultsByAPI) {
			const resultsContainer = document.getElementById('search-results');
			
			let html = '';

			// Mostrar mapa primeiro se houver resultados
			if (resultsByAPI.maps.length > 0) {
				const mapResult = resultsByAPI.maps[0];
				html += `
					<div class="map-section">
						<div class="map-container">
							<h3 class="map-title">Localização Encontrada</h3>
							<p style="color: #6b7280; margin-bottom: 1.5rem;">${mapResult.display_name}</p>
							<iframe 
								class="map-frame"
								src="https://www.openstreetmap.org/export/embed.html?bbox=${parseFloat(mapResult.lon)-0.01},${parseFloat(mapResult.lat)-0.01},${parseFloat(mapResult.lon)+0.01},${parseFloat(mapResult.lat)+0.01}&layer=mapnik&marker=${mapResult.lat},${mapResult.lon}"
								allowfullscreen>
							</iframe>
						</div>
					</div>
				`;
			}

			// Verificar se há resultados de outras APIs
			const hasOtherResults = resultsByAPI.wikipedia.length > 0 || 
									resultsByAPI.reddit.length > 0 || 
									resultsByAPI.duckduckgo.length > 0 || 
									resultsByAPI.dictionary.length > 0;

			if (!hasOtherResults && resultsByAPI.maps.length === 0) {
				resultsContainer.innerHTML = '<div class="no-results">Nenhum resultado encontrado.</div>';
				return;
			}

			if (hasOtherResults) {
				html += '<div class="results-columns">';

				// Criar seções para cada API com resultados
				const apis = [
					{ name: 'wikipedia', title: 'Wikipedia', results: resultsByAPI.wikipedia },
					{ name: 'reddit', title: 'Reddit', results: resultsByAPI.reddit },
					{ name: 'duckduckgo', title: 'DuckDuckGo', results: resultsByAPI.duckduckgo },
					{ name: 'dictionary', title: 'Dicionário', results: resultsByAPI.dictionary }
				];

				apis.forEach(api => {
					if (api.results.length > 0) {
						html += `
							<div class="api-column">
								<div class="column-header">${api.title}</div>
						`;

						api.results.forEach(result => {
							// Extrair o texto do título e o link
							const titleMatch = result.title.match(/<a[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>/);
							const titleText = titleMatch ? titleMatch[2] : result.title.replace(/<[^>]*>/g, '');
							const linkUrl = titleMatch ? titleMatch[1] : '#';

							html += `
								<div class="result-item">
									<div class="result-title">${titleText}</div>
									<a href="${linkUrl}" target="_blank" class="result-link">${linkUrl}</a>
									<div class="result-description">${result.description.replace(/<[^>]*>/g, '')}</div>
									<div class="result-source">${api.title}</div>
								</div>
							`;
						});

						html += '</div>';
					}
				});

				html += '</div>';
			}

			resultsContainer.innerHTML = html;

			// Configurar animações de scroll
			setTimeout(() => {
				const elementsToAnimate = resultsContainer.querySelectorAll('.map-section, .result-item');
				elementsToAnimate.forEach(element => {
					observer.observe(element);
				});
			}, 100);
		}

		async function searchMaps(query) {
			try {
				const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&addressdetails=1&limit=1`;
				const response = await fetch(url);
				const data = await response.json();
				return data;
			} catch (error) {
				return [];
			}
		}

		async function searchWikipedia(query) {
			try {
				const url = `https://pt.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&format=json&origin=*&srlimit=3`;
				const response = await fetch(url);
				const data = await response.json();

				return data.query.search.map(item => ({
					title: `<a href="https://pt.wikipedia.org/wiki/${encodeURIComponent(item.title.replace(/ /g, '_'))}" target="_blank">${item.title}</a>`,
					description: item.snippet + '...',
					meta: null
				}));
			} catch (error) {
				return [];
			}
		}

		async function searchReddit(query) {
			try {
				const url = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=3`;
				const response = await fetch(url);
				const data = await response.json();

				return data.data.children.map(post => {
					const item = post.data;
					return {
						title: `<a href="https://www.reddit.com${item.permalink}" target="_blank">${item.title}</a>`,
						description: item.selftext ? item.selftext.substring(0, 200) + '...' : 'Clique para ver o conteúdo completo',
						meta: `👍 ${item.ups} upvotes • 💬 ${item.num_comments} comentários • r/${item.subreddit}`
					};
				});
			} catch (error) {
				return [];
			}
		}

		async function searchDuckDuckGo(query) {
			try {
				const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json`;
				const response = await fetch(url);
				const data = await response.json();

				const results = [];

				if (data.Abstract) {
					results.push({
						title: data.Heading || query,
						description: data.Abstract,
						meta: data.AbstractURL ? `<a href="${data.AbstractURL}" target="_blank">Leia mais →</a>` : null
					});
				}

				if (data.RelatedTopics && data.RelatedTopics.length > 0) {
					data.RelatedTopics.slice(0, 2).forEach(topic => {
						if (topic.Text) {
							results.push({
								title: topic.FirstURL ? `<a href="${topic.FirstURL}" target="_blank">${topic.Text.split(' - ')[0]}</a>` : topic.Text.split(' - ')[0],
								description: topic.Text,
								meta: null
							});
						}
					});
				}

				return results;
			} catch (error) {
				return [];
			}
		}

		async function searchDictionary(query) {
			try {
				// Só procurar no dicionário se for uma palavra simples em inglês
				if (query.split(' ').length > 1 || !/^[a-zA-Z]+$/.test(query)) {
					return [];
				}

				const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(query.toLowerCase())}`;
				const response = await fetch(url);
				
				if (!response.ok) return [];

				const data = await response.json();
				const entry = data[0];

				if (!entry) return [];

				const meaning = entry.meanings[0];
				const definition = meaning.definitions[0];

				return [{
					title: `${entry.word} ${entry.phonetic ? `(${entry.phonetic})` : ''}`,
					description: `<strong>${meaning.partOfSpeech}</strong>: ${definition.definition}${definition.example ? `<br><em>Exemplo: "${definition.example}"</em>` : ''}`,
					meta: null
				}];
			} catch (error) {
				return [];
			}
		}
	</script>
</body>
</html>
